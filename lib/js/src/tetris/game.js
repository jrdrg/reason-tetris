// Generated by BUCKLESCRIPT VERSION 2.0.0, PLEASE EDIT WITH CARE
'use strict';

var List             = require("bs-platform/lib/js/list.js");
var $$Array          = require("bs-platform/lib/js/array.js");
var Caml_array       = require("bs-platform/lib/js/caml_array.js");
var Caml_int32       = require("bs-platform/lib/js/caml_int32.js");
var Constants$Tetris = require("./constants.js");

function initBoard() {
  return Caml_array.caml_make_vect(Caml_int32.imul(Constants$Tetris.boardSize[/* height */0], Constants$Tetris.boardSize[/* width */1]), /* Empty */1);
}

function blockAt(width, height, x, y, array) {
  var maxIndex = Caml_int32.imul(width, height);
  var index = Caml_int32.imul(y, width) + Caml_int32.mod_(x, width) | 0;
  if (index < maxIndex) {
    return /* Some */[Caml_array.caml_array_get(array, index)];
  } else {
    return /* None */0;
  }
}

function blockPosition(param, param$1, param$2) {
  return blockAt(Constants$Tetris.pieceSize, Constants$Tetris.pieceSize, param, param$1, param$2);
}

var partial_arg = Constants$Tetris.boardSize[/* height */0];

var partial_arg$1 = Constants$Tetris.boardSize[/* width */1];

function boardPosition(param, param$1, param$2) {
  return blockAt(partial_arg$1, partial_arg, param, param$1, param$2);
}

function range(first, last) {
  var _range = function (curr, max, list) {
    if (curr < max) {
      return /* :: */[
              curr,
              _range(curr + 1 | 0, max, list)
            ];
    } else {
      return list;
    }
  };
  return _range(first, last, /* [] */0);
}

function isColliding(_, _$1) {
  return /* true */1;
}

function rotateRight(blocks) {
  List.rev(range(0, Constants$Tetris.pieceSize));
  range(0, Constants$Tetris.pieceSize);
  var start_000 = Caml_array.caml_make_vect(Caml_int32.imul(Constants$Tetris.pieceSize, Constants$Tetris.pieceSize), /* Empty */1);
  var start = /* tuple */[
    start_000,
    0
  ];
  var f = function (param, _) {
    return /* tuple */[
            param[0],
            param[1]
          ];
  };
  return $$Array.fold_left(f, start, blocks)[0];
}

function rotateLeft(blocks) {
  return blocks;
}

function movePieceDown(piece, velocity, _) {
  return /* record */[
          /* shape */piece[/* shape */0],
          /* blocks */piece[/* blocks */1],
          /* state */piece[/* state */2],
          /* offsetX */piece[/* offsetX */3],
          /* offsetY */piece[/* offsetY */4] + velocity | 0
        ];
}

function updateTick(_, board) {
  return board;
}

exports.initBoard     = initBoard;
exports.blockAt       = blockAt;
exports.blockPosition = blockPosition;
exports.boardPosition = boardPosition;
exports.range         = range;
exports.isColliding   = isColliding;
exports.rotateRight   = rotateRight;
exports.rotateLeft    = rotateLeft;
exports.movePieceDown = movePieceDown;
exports.updateTick    = updateTick;
/* No side effect */
